"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.YouTubeAudioV2 = void 0;
const node_fs_1 = __importDefault(require("node:fs"));
const node_path_1 = require("node:path");
const node_crypto_1 = require("node:crypto");
const ytdl_core_1 = __importDefault(require("ytdl-core"));
const fluent_ffmpeg_1 = __importDefault(require("fluent-ffmpeg"));
const search_1 = require("./search");
class YouTubeAudioV2 extends search_1.YouTubeSearch {
    dir;
    useBuffer;
    fname;
    constructor(url) {
        super(url);
        this.dir = null;
        this.useBuffer = false;
    }
    outputFile(dir) {
        dir = dir.endsWith("/") ? dir : dir + "/";
        if (!node_fs_1.default.existsSync(dir))
            node_fs_1.default.mkdirSync(dir);
        this.dir = dir;
        return this;
    }
    outputBuffer() {
        this.useBuffer = true;
        return this;
    }
    filename(fname) {
        this.fname = fname;
        return this;
    }
    download() {
        return new Promise(async (resolve, reject) => {
            try {
                const metadata = await this.getSpecificVideo();
                const stream = (0, ytdl_core_1.default)(metadata.url, { filter: "audioonly", quality: 140 });
                if (this.dir) {
                    const audio = this.dir +
                        (this.fname ||
                            (metadata.title.match(/\//g) && metadata.title.replace(/\//g, "_")) ||
                            metadata.title) +
                        ".ogg";
                    (0, fluent_ffmpeg_1.default)(stream)
                        .audioCodec("libvorbis")
                        .audioBitrate("128k")
                        .save(audio)
                        .on("error", (error) => reject(error))
                        .on("end", () => {
                        resolve({
                            ...metadata,
                            audioPath: audio,
                        });
                    });
                }
                else {
                    if (!node_fs_1.default.existsSync((0, node_path_1.join)(__dirname, "../temp"))) {
                        node_fs_1.default.mkdirSync((0, node_path_1.join)(__dirname, "../temp"));
                    }
                    const tempAudio = (0, node_path_1.join)(__dirname, "../temp/" + (0, node_crypto_1.randomBytes)(100).toString("hex") + ".ogg");
                    (0, fluent_ffmpeg_1.default)(stream)
                        .audioCodec("libvorbis")
                        .audioBitrate("128k")
                        .save(tempAudio)
                        .on("error", (e) => reject(e))
                        .on("end", () => {
                        const stream = node_fs_1.default.createReadStream(tempAudio);
                        const data = [];
                        stream.on("data", (chunk) => {
                            data.push(chunk);
                        });
                        stream.on("end", async () => {
                            await node_fs_1.default.promises.unlink(tempAudio).then(() => {
                                resolve({
                                    ...metadata,
                                    audioBuffer: Buffer.concat(data),
                                });
                            });
                        });
                        stream.on("error", (e) => reject(e));
                    });
                }
            }
            catch (e) {
                reject(e);
            }
        });
    }
}
exports.YouTubeAudioV2 = YouTubeAudioV2;
