"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.YouTubeVideo = void 0;
const node_fs_1 = __importDefault(require("node:fs"));
const node_path_1 = require("node:path");
const node_crypto_1 = require("node:crypto");
const ytdl_core_1 = __importDefault(require("ytdl-core"));
const fluent_ffmpeg_1 = __importDefault(require("fluent-ffmpeg"));
const search_1 = require("./search");
class YouTubeVideo extends search_1.YouTubeSearch {
    ql;
    dir;
    fname;
    constructor(url) {
        super(url);
    }
    quality(ql) {
        this.ql = ql;
        return this;
    }
    outdir(dir) {
        dir = dir.endsWith("/") ? dir : dir + "/";
        if (!node_fs_1.default.existsSync(dir))
            node_fs_1.default.mkdirSync(dir);
        this.dir = dir;
        return this;
    }
    filename(fname) {
        this.fname = fname;
        return this;
    }
    download() {
        return new Promise(async (resolve, reject) => {
            try {
                const metadata = await this.getSpecificVideo();
                const audioStream = (0, ytdl_core_1.default)(metadata.url, { filter: "audioonly", quality: 140 });
                const videoStream = (0, ytdl_core_1.default)(metadata.url, { filter: "videoonly", quality: await this.parseQl(this.ql) });
                if (!node_fs_1.default.existsSync((0, node_path_1.join)(__dirname, "../temp"))) {
                    await node_fs_1.default.promises.mkdir((0, node_path_1.join)(__dirname, "../temp"));
                }
                const tempAudio = (0, node_path_1.join)(__dirname, "../temp/" + (0, node_crypto_1.randomBytes)(100).toString("hex") + ".m4a");
                const videoPath = this.dir +
                    (this.fname ||
                        (metadata.title.match(/\//g) && metadata.title.replace(/\//g, "_")) ||
                        metadata.title) +
                    ".mp4";
                (0, fluent_ffmpeg_1.default)(audioStream)
                    .save(tempAudio)
                    .on("error", (e) => reject(e))
                    .on("end", () => {
                    (0, fluent_ffmpeg_1.default)(videoStream)
                        .addInput(tempAudio)
                        .outputOptions(["-map", "0", "-map", "1:a", "-c:v", "copy", "-shortest"])
                        .save(videoPath)
                        .on("error", async (e) => {
                        if (node_fs_1.default.existsSync(tempAudio)) {
                            await node_fs_1.default.promises.unlink(tempAudio);
                        }
                        reject(e);
                    })
                        .on("end", async () => {
                        await node_fs_1.default.promises.unlink(tempAudio).then(() => {
                            resolve({
                                ...metadata,
                                videoPath,
                            });
                        });
                    });
                });
            }
            catch (e) {
                reject(e);
            }
        });
    }
    parseQl(ql) {
        return new Promise((resolve, reject) => {
            let result;
            switch (ql) {
                case "144p":
                    result = "160";
                    break;
                case "240p":
                    result = "133";
                    break;
                case "360p":
                    result = "134";
                    break;
                case "480p":
                    result = "135";
                    break;
                case "720p":
                    result = "136";
                    break;
                case "1080p":
                    result = "137";
                    break;
                default:
                    reject(Error("Quality not found"));
            }
            resolve(result);
        });
    }
}
exports.YouTubeVideo = YouTubeVideo;
